---
template: post
title: Effective Javaを読んで
slug: /posts/read-effective-java-1
draft: false
date: 2021-03-14T06:42:11.997Z
description: Effective Javaを読んでの備忘録
category: BOOK
tags:
  - Effective Java
---
もっとちゃんとJavaのこと理解したいなと思って、Effective Javaを読んだ。

# オブジェクトの生成と消滅
## コンストラクタの代わりにstaticファクトリメソッドを検討する
- staticファクトリメソッドのメリット
  - コンストラクタと異なって、名前を持つから返されるオブジェクトが何者かわかりやすい
  - コンストラクタと異なって、呼び出しごとに新たなオブジェクトを生成する必要がない
  - コンストラクタと異なって、メソッドの戻り値型の任意のサブタイプのオブジェクトを返せる
  - 返されるオブジェクトのクラスは、入力パラメータの値に応じて呼び出しごとに変えられる
  - 返されるオブジェクトのクラスは、そのstaticファクトリメソッドを含むクラスが書かれた時点で存在する必要さえない
- staticファクトリメソッドのデメリット
  - publicあるいはprotectedのコンストラクタを持たないクラスのサブクラスを作れない制約がある
  - プログラマがstaticファクトリメソッドを見つけるのが難しい
    - 共通する命名規約を遵守することで、軽減できる
      - from：単一パラメータを受け取り、当の肩を持つ対応するインスタンスを返す型変換メソッド
      - of：複数のパラメータを受け取り、それらを含んだ当の型のインスタンスを返す集約メソッド
      - valueOf：fromやofの代わりとなる、冗長な名前のメソッド
      - instance あるいは getInstance：パラメータがあればそのパラメータで表されているインスタンスを返すが、必ずしも同じ値を持つとは限らない
      - create あるいは newInstance：呼び出しごとにメソッドは新たなインスタンスを返す
      - getType：ファクトリメソッドが対象のクラスとは異なるクラスにある場合に使われる。Typeはファクトリメソッドから返されるオブジェクトの型を示している。（getInstanceと類似）
      - newType：ファクトリメソッドが対象のクラスとは異なるクラスにある場合に使われる。Typeはファクトリメソッドから返されるオブジェクトの型を示している。（newInstanceと類似）
      - type：getTypeやnewTypeの代わりとなる、簡潔な名前のメソッド。

## 多くのコンストラクタパラメータに直面したときはビルダーを検討する
テレスコーピング・コンストラクタ・パターンは、多くのパラメータがある場合、クライアントのコードを書くのが困難になり、可読性が落ちる。JavaBeansパターン（setter）は、生成過程の途中で不整合な状態にあるかもしれない。クラスを不変にする可能性を排除してしまう。\
テレスコーピング・コンストラクタ・パターンの安全性とJavaBeansパターンの可読性を組み合わせたのがBuilderパターン。Builderパターンは、コードを書くのも読むのも容易になる。\
Builderパターンの欠点は、「最初にビルダーを生成しないといけない」、「記述が長くなってしまう」。将来的にパラメータが増えそうなときは、最初からビルダーで始めるのがたいていよい。\
ビルダーによるクライアントのコードは、テレスコーピング・コンストラクタ・パターンよりは読みやすく、JavaBeansバターンよりは安全。

## privateコンストラクタかenum型でシングルトン特性を強制する
インターフェースを実装していない限り、シングルトンをモック実装で置き換えることが不可能なため、クラスをシングルトンにすると、クライアントのテストを困難にする。\

- シングルトンを実装するための方法
  - public finalのフィールド
  - staticファクトリメソッド
  - 単一要素を持つenumを宣言

シングルトンを保証し続けるには、すべてのインスタンスフィールドをtransientと宣言して、readResolveメソッドを提供しなければならない。そうしなければ、シリアライズされたインスタンスをデシリアライズするごとに、新たなインスタンスが生成されてしまう。

## 資源を直接結び付けるよりも依存性注入を選ぶ
多くのクラスが1つ以上の下層の資源に依存している。\
クラスの複数のインスタンスをサポートして、それぞれのインスタンスでクライアントが望む資源を使えることが必要で、新しいインスタンスを生成するときにコンストラクタに資源を渡すことが単純な解決策になる。\
依存性注入は柔軟性とテスト可能性を大幅に向上するが、普通に数千の依存を含むような大きなプロジェクトを撮り散らかす可能性があるが、依存性注入フレームワークを使えば取り除ける。\

## 不必要なオブジェクトの生成を避ける
機能的に同じオブジェクトが必要な度に新たに生成するよりは、一つのオブジェクトを再利用する方が適切。オブジェクトが不変であれば、常に再利用できる。

## 使われなくなったオブジェクト参照を取り除く
ガベージコレクションを持つ言語は、オブジェクトを使い終えたときにそれが自動的に回収されることで、プログラマとしての仕事は楽になる。\
スタックが大きくなってその後小さくなると、スタックから取り出されたオブジェクトはガベージコレクトされない。スタックはそれらのオブジェクトに対する使われなくなった参照を保持しているため。\
クラスが独自のメモリを管理しているときは、プログラマはメモリリークに対して注意を払うべき。要素が解放されるときには、その要素に含まれたすべてのオブジェクト参照にnullを設定すべき。

## ファイナライズとクリーナーを避ける
ファイナライザは予想不可能で、たいていは危険で、一般的には必要ない。

- ファイナライザとクリーナーの欠点
  - 即座に実行される保証がない。オブジェクトが到達不可能となってから実行されるまでの時間は、任意の長さ。
  
セーフティネットとして、あるいは重要でないネイティブピアの資源の解放のためを除いて、クリーナー（またはファイナライザ）は使わない方がよい。

## try-finallyよりもtry-with-resourcesを選ぶ
Javaライブラリは、closeメソッドを呼び出して手作業でクローズしなければならない多くの資源を含んでいる。例として、InputStream、OutputStream、java.sql.Connectionが含まれる。\
クローズしなければならない資源を扱うときは、いつでもtry-with-resourcesを使うのがよい。その結果、コードは短くて明瞭で、生成される例外は有用なものになる。
