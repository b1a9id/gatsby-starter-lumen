---
template: post
title: MySQL徹底入門を読んで
slug: /posts/read-mysql-beginner
draft: true
date: 2021-07-09T10:03:00.521Z
description: 
---
# 運用に必要な知識
## MySQLのプロセスアーキテクチャ
- MySQLはシングルプロセス・マルチスレッドモデルのデータベース。
  - psコマンドのauxや-elfなどのオプションではmysqldのプロセスは1つしか見えない。
  - 内部的には複数のスレッドを使い分けている
- スレッドは、フォアグランドスレッドとバックグランドスレッドに分けられる
  - フォアグランドスレッドは外部のクライアントと1対1で紐づく
    - 1つの接続が1つのスレッドになり、接続が切断されるまでの同一のスレッドが処理をする
  - 現在のコネクション（= スレッド）の情報はperformance_schemaのthreadsテーブルまたはSHOW PROCESSLISTで確認できる
    - 実行時のオーバーヘッドや情報の粒度などからperformance_schema.threadsテーブルの方が推奨されている

## MySQLのパラメータ
- MySQLにはたくさんのパラメータ（設定可能項目）があり、分類ごとにいくつかの特性を持っている。
  - オンラインで変更が可能なパラメータと設定変更にMySQLの再起動が必要なパラメータがある。
- my.cnfの読み込み順序
  - /etc/my.cnf
  - /etc/mysql/my.cnf
  - SYSCONFDIR/my.cnf
  - $MYSQL_HOME/my.cnf
  - --default-extra-file
  - $HOME/my.cnf
  - $HOME/.mylogin.cnf
  - DATADIR/mysqld-auto.cnf
  - コマンドラインオプションで与えられた引数
- オンラインで変更したパラメータを永続化するにはSET PERSISTステートメントが使える
  - SET PERSIST/SET PERSIST_ONLYで変更されたパラメータはDATADIR/mysqld-auto.cnfにJSONの形式で記録される
    - このファイルは管理者が直接編集することを想定していない。
    - mysqld-auto.cnfに記録されたパラメータの設定を削除するには、RESET PERSISTステートメントを利用する
    - 各パラメータがどこで設定されたかはperformance_schema.variables_infoテーブルで確認できる

## MySQLのバージョン情報
MySQLのバージョンは、SELECT VERSION(); や SHOW VARIABLES LIKE 'version'; などで調べることができる。

# 運用設計
## バージョン選定
MySQL 8.0系列は同一リリース系列内でも非互換性があるため、バージョンの選定は慎重にされなくてはならない。\
クライアントやライブラリのバージョンはMySQLサーバと同じかそれ以上であることが必須。MySQL 8.0系列ではバージョン番号の信仰に伴って新機能が追加されてしまうため、 その機能やその周辺に新規にバグが内在する可能性がある。

現時点で確実に進められることは次の通り。
- 導入時点での最新バージョンを選び動作確認をする
- 導入以後のアップグレードに備えてSQLレベルでの非互換性を検出できるように回帰テストを作成する
- アップグレードをする際にはクライアントのバージョンを先にあげる

## バックアップ設計
- バックアップの間隔
  - バックアップにはフルバックアップと増分バックアップがあり、両方揃って初めて任意の時点のデータを復元できる
  - フルバックアップの頻度
    - 目標復旧時間（RTO）に応じてベースとなるフルバックアップの間隔を決める
  - 増分バックアップの頻度
    - レプリケーション構成を組んでいる場合、間違いなくマスターではバイナリログが出力されているが、これをマスターのストレージ以外の場所に保管しておくことが必要。
      - マスターだけにバイナリログが保管されている（増分バックアップを取得しない）場合、MySQLが稼働しているマシンが完全に壊れ、ストレージからMySQLのデータはおろかバイナリログすら取り出せなくなってしまうと最後のフルバックアップの時点までしか復元できない
  - リストアにかかる時間の見積もり
    - フルバックアップの頻度を決める上で重要なのが「フルバックアップをリストアするのにかかる時間」と「一定期間のバイナリログを適用するのにかかる時間」。これらをできるだけ正しく見積もることは大切。
    - フルバックアップのリストア時間はデータの総容量に依存し、バイナリログの適用はバイナリログの量（= データが更新される頻度）に依存する
  - バックアップの運用計画に関するパラメータ
    - 増分バックアップの計画に大切なパラメータとしてbinlog_expire_logs_secondsという値がある。
      - これは、現在のバイナリログがスイッチした時点で過去の古いバイナリログを削除するためのパラメータ。
    - バイナリログがスイッチするタイミングは、max_binlog_sizeというパラメータで決定される。
      - 追記されていったバイナリログのサイズがこのパラメータで設定されて値よりも大きくなると、バイナリログのスイッチが発生する。
    - log_slave_updates
      - デフォルトはONで、スレーブはマスターからレプリケーションで受け取った更新差分を自身（= スレーブ）のバイナリログに出力する。これによりマスターとスレーブで二重にバイナリログが保管され、バイナリログの喪失への耐性が上がる。
      
## モニタリング計画
MySQLが機能を提供しているかどうかを確認する「死活監視」と、中長期的にリソースの利用状況がどうなっていくかを確認する「リソース監視」の2つが必要。

- 死活監視
  - MySQLの機能を提供するプロセスはmysqld。これが起動していない場合、MySQLはその機能を提供できない
  - mysqld_safeというプロセスが起動している場合もあるが、これはmysqldプロセスの起動を補助するラッパースクリプトなのでmysqldではない
  - MySQLにバンドルされているmysqladminコマンドにはpingサブコマンドがある
    - 「MySQLプロトコルでmysqldに対してアクセスし、応答があれば成功、なければ失敗」と判定する
  - 「MySQLとしては異常はないが、MySQLに原因がある」ような状況を発見するには、アプリケーションログをしっかり監視するのが有効
  - 死活監視の内容
    - MySQLプロトコルでの接続が可能か
    - SHW PROCESSLIST上で長時間実行され続けているクエリがないか
    - 現在の接続数とmax_connectionsを比較して、100%に近づいていないか
    - スレーブであれば、SHOW SLAVE STATUSのSeconds_Behind_Master（= 更新がマスターに実行されてからスレーブの反映までかかっている時間）が大きくなっていないか
    - 各テーブルのAUTO_INCREMENT属性カラムが、データ型の最大値近くまで払い出されていないか
    - Uptimeが小さすぎないか
- リソース監視
  - 直接的なエラー以外の、レスポンス速度低下の原因究明や性能限界の計測に役立つ
  - 「問題発生以前」、「問題発生中」、「問題終息後」の３時点のリソースを比較するためにも継続的なデータの蓄積は必須
- MySQLの各種ログ
  - エラーログ
    - MySQLサーバはプロセスに発生した異常をエラーログに出力する
  - スロークエリログ
    - mysqldがSQLを処理するのにかかった時間を記録するログ
    - クエリの処理にかかった時間はMySQLサーバを利用する環境にとって非常に重要
    - できる限り有効にしておくのがよい
    - my.cnfにslow_query_logオプションを記載する or サーバ変数のslow_query_logをONに設定
  - ジェネラルログ
    - 一般クエリログとも呼ばれ、mysqldが受け取ったすべてのクエリを記録するためのログ
    - アプリケーションのデバッグ用途に用いるためのログであり、恒常的にONにしておくようなログではない
  - ログファイルのローテーション
    - MySQLサーバはそれ単体ではログローテーションの仕組みを持たない
  - その他のログと名のつくもの
    - MySQLサーバが内部動作を記録するためのログであり、テキストとして開くことはないが、削除しないようにしないといけない
      - InnoDB ログ
      - バイナリログ
      - リレーログ

## 実際の運用作業
### パラメータチューニング
すこしくらいパラメータを変更したところでパフォーマンスが劇的によくなることはない。事前に綿密な計算のもと、パラメータを算出するよりも運用中に効果を測定しながら継続的にパラメータの最適値に近づけていくことが大切。

- 事前に計算しておくべきパラメータ
  - innodb_buffer_pool_sizeは重要なオプション
    - InnoDBのすべてのテーブルで利用されるバッファプール（メモリ上に配置）のサイズを指定する
    - SELECTのときにキャッシュとして使われるのみならず、InnoDBのすべての操作を一度バッファプールを経由して処理されるため、あらゆるDMLやDDLの速度に影響を及ぼす。
    - 物理メモリが小さい（例えば4GB以下）ときは50%程度、十分大きい（例えば12GB以上）ときは80%などと単純な割合ではなく、InnoDBバッファプール以外にどれくらいメモリを残しておくべきかから算出するのがよい
    - innodb_buffer_pool_sizeはオンラインで変更できる（MySQL 5.6とそれ以前は再起動が必要だった）

### クエリチューニング
MySQLのパフォーマンス問題の多くはクエリ単位に分解して考えることがベター。単一のクエリが遅い場合はもちろん、複数のクエリがロックやリソースの競合を起こしている場合でも、個々のクエリのスピードをあげてやることで全体としてのパフォーマンを改善できる\
パラメータのチューニングがせいぜい数倍程度にしかパフォーマンスの問題を改善できないのに対し、正しくチューニングされたクエリは数百倍から数千倍のパフォーマンスが出る。

- インデックスの仕組み
  - 最もコストパフォーマンスが高いのは「インデックスを使わせること」
  - INSERT/UPDATE/DELETEといった更新処理はインデックスも同時にメンテナンスしなければならないため、更新の負荷はインデックスがない場合よりも大きくなる
  - 特定のクエリに対してベストなインデックスであっても、クエリの形が変わると同じインデックスがベストとは限らない
  - 複数カラムからなるインデックスはカラムの順番で効率が変わることがある、インデックスの大部分を操作しなければならないアクセスパターンは効率がよくない
- インデックスによるWHERE句のチューニング
  - カードをめくって目視が1番コストの高い動作になるため、可能な限りこれを避けるようにインデックスを追加していく
  - どのくらいカードをめくって目視が発生する見積もりであるかは、実行したいクエリの先頭にEXPLAINキーワードをつけることで確認できる
    - rowsがカードをめくって目視する見積もりを表しており、filteredがカードをめくってチェックしたうち、何%程度が実際にマッチする行である見積もりを表している
    - ExtraのUsing whereがインデックスだけではWHERE句を解決しきれないので目視のフィルタリングが必要であることを表している
  - 不要なインデックスを作ってしまうことを重要視するよりも、不要になったインデックスを安全に検出して削除することを継続指定実践していいくのがよい
- WHERE句のチューニングによる改善すべきクエリの特定
  - WHERE句にインデックスが使えずに非効率になっているクエリの特定は容易
    - 特定にはスロークエリログまたはperformance_schemaが使える
      - 実行時にフィルタがかけられる前者の方が便利
      - 後者はWHERE句などの定数をノーマライズしたダイジェストと呼ばれる単位で蓄積していくため、「リソースに余裕がある何の問題もないが、トラフィックがバーストすると問題として顕在化する」ようなクエリを探すのに便利
      - スロークエリログの Rows_examined / Rows_sent の値が1 に近ければ近いほどWHERE句の効率が良く、大きければ大きいほど非効率
- インデックスによる ORDER BY ... LIMIT のチューニング
  - MySQLのインデックスはWHERE句による絞り込み以外に、ORDER BY句に対する効率化にも利用可能
- ORDER BY ... LIMIT のための「優先度付きキュー」によるソート
  - 「優先度付きキュー」はMySQL 5.6とそれ以降で追加された比較的新しいORDER BY がLIMIT句とともに使われている場合の最適化方式
  - ソートバッファを優先度付きキューとして扱うことでORDER BY ... LIMITを省メモリで効率的に処理する最適化が働く。
    - この最適が行われたとしても「ソートに必要なカラムの値をすべて読み取らなければならない」という点は変わらない
    - この最適化はオプティマイザが自動で選択するので、「チューニング」ではなく「そういうもの」と知っていればよい
